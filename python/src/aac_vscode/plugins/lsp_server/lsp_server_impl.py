"""The AaC LSP Server plugin implementation module."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by aac gen-plugin, and it won't be overwritten if the file already exists.

# There may be some unused imports depending on the definition of the plugin...but that's ok
from aac.execute.aac_execution_result import (
    ExecutionResult,
    ExecutionStatus,
    ExecutionMessage,
)
from aac.lang.schema import Schema
from aac.lang.plugininputvalue import PluginInputValue
from aac.context.language_context import LanguageContext
from aac.context.definition import Definition
from aac.context.source_location import SourceLocation
from typing import Any, Callable
from aac_vscode.plugins.lsp_server.language_server import AacLanguageServer


plugin_name = "LSP Server"


def start_lsp_io() -> ExecutionResult:
    """Business logic for the start-lsp-io command."""

    aac_language_server = AacLanguageServer()
    return _start_lsp("start-lsp-io", aac_language_server.start_io)


def start_lsp_tcp(host: str, port: float) -> ExecutionResult:
    """Business logic for the start-lsp-tcp command."""

    aac_language_server = AacLanguageServer()
    function_kwargs = {"host": host, "port": port}
    return _start_lsp("start-lsp-tcp", aac_language_server.start_tcp, **function_kwargs)

def _start_lsp(cmd_name: str, language_server_start_function: Callable, **start_function_kwargs) -> ExecutionResult:
    """Start the LSP server."""

    status = ExecutionStatus.SUCCESS
    messages: list[ExecutionMessage] = []
    try:
        output = language_server_start_function(**start_function_kwargs)
        messages.extend = [ExecutionMessage(m, None, None) for m in output.messages if m]
        return ExecutionResult(plugin_name, cmd_name, status, messages)

    except Exception as error:
        status = ExecutionStatus.GENERAL_FAILURE
        messages.append(ExecutionMessage(str(error), None, None))
        return ExecutionResult(plugin_name, cmd_name, status, messages)
